# Лабораторная работа №1

В этой папке находится моё решение лабораторной работы №1 вариант №10.

## Задание

Нужно было реализовать систему, которая хранит идентификаторы.

Количество идентификаторов больше 200 (в моей работе есть тесты на 10, 50, 100, 500, 1000, 1500, 2000) идентификаторов.

Длина идентификатора больше 32 символов (в моей работе это 70 символов).

## Реализация

Написан абстрактный класс IdTable, а от него унаследованы 2 таблицы. Одна основывается на структуре данных "Список", а вторая на "Бинарное дерево".

Интерфейс таблиц:

- `add_id(key)` - добавляет идентификатор `key` в таблицу
- `search_id(key)` - возвращает `true`, если идентификатор `key` есть в таблице, иначе вернет `false`
- `print_table()` - выводит в поток вывода все идентификаторы, которые есть в таблице
- `get_count_operation()` - выводит количество операций сравнения, которые произошли за время работы таблицы

Для тестирования таблиц были написаны 2 функции:

1. `test_easy()` - простая функция, которая показывает, как всё работает. В функцию `my_test_id_table` передается таблица (это возможно благородя наследованию), которая тестирует эту таблицу. В тесте есть операции добавления и поиска идентификаторов. При желании можно добавить строчку `id_table.print_table();`, которая будет печатать идентификаторы в таблице.
2. `speed_comparison_test()` - функция, которая хранит в себе названия файлов с тестами (в переменной `files`), а потом тестирует на них таблицы с помощью функции `test_for_file`. Выводит в консоль количество тестов и количество сравнений для этого теста. В конце выводит отношение количество сравнений Списка к Бинарному дереву.

## Вывод работы

В ходе работы были написаны таблицы идентификаторов на основе структур данных "Список" и "Бинарное дерево". По результатам тестов можно сделать вывод, что количество операций сравнения (КОС) у Списка существенно выше, чем у Бинарного дерева. Отношение КОС увеличивается примерно в два раза, если количество тестов увеличивать в два раза. Значит, функция роста КОС у Списка имеет экспоненциальную сложность по сравнению с Бинарным деревом.

Это ожидаемый результат, так как сложность Бинарного дерева (на вставку и поиск) равна `O(log(n))`, а сложность Списка равна `O(n)`. Если возвести и то, и то в степень экспоненты, то увидим, что это совпадает с полученным наблюдением в результате выполнения лабораторной работы. 